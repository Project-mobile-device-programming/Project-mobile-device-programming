# Project-mobile-device-programming
## KẾ HOẠCH TRIỂN KHAI HỆ THỐNG THU PHÍ BẢN QUYỀN NHẠC (1 TUẦN)
![image](https://github.com/user-attachments/assets/8c49215d-6719-41fd-83c1-433885dc2aba)
![image](https://github.com/user-attachments/assets/20b87999-0397-4fe0-a3a4-b45b6390f324)
## SPORTIFY INTERFACE DESIGN SAMPLE
![image](https://github.com/user-attachments/assets/bbcf05cb-f11b-49b8-b0d0-08c6c979c3e0)
## CÁC BƯỚC THIẾT KẾ GIAO DIỆN MOBILE APP NGHE NHẠC
![image](https://github.com/user-attachments/assets/bb354d4f-32fe-4b28-89dc-b5dd403f5f7e)
## BẢN THIẾT KẾ CỦA APP 
![image](https://github.com/user-attachments/assets/bf2cb19a-981f-4dd7-968c-f346fa362193)
![image](https://github.com/user-attachments/assets/1b54b03b-be0b-4808-b229-99f1506b007c)
![image](https://github.com/user-attachments/assets/cf389fa3-dae6-4c6d-ac7c-932cc6db7282)
## Đang ở giai đoạn thực thi 
### Mô tả giai đoạn dự án:

Dự án hiện đang trong giai đoạn thực thi và tập trung vào việc xây dựng một ứng dụng di động có tên "SPIKETUNE". Ứng dụng này được thiết kế nhằm cung cấp một nền tảng độc đáo, nơi người dùng có thể tương tác với âm nhạc một cách sáng tạo, kết hợp các yếu tố âm thanh để kể những câu chuyện mang đậm dấu ấn cá nhân.

### Các kết quả phát triển giao diện ban đầu bao gồm:

Màn hình khởi động (Splash Screen): Đây là giao diện đầu tiên mà người dùng nhìn thấy khi khởi chạy ứng dụng. Thiết kế hiện tại của màn hình khởi động tập trung vào việc xây dựng nhận diện thương hiệu mạnh mẽ thông qua việc hiển thị nổi bật tên ứng dụng "SPIKETUNE" bằng phông chữ rõ ràng trên một dải màu tím đậm ở phía trên. Trung tâm màn hình thu hút sự chú ý bằng logo đặc trưng của ứng dụng: một hình vuông bo tròn màu tím than chứa biểu tượng cách điệu của nút "Play" màu xanh dương tươi kết hợp với các đường sóng âm thanh, tượng trưng cho chức năng cốt lõi của ứng dụng. Ngay bên dưới logo là tên ứng dụng "SPIKETUNE" được lặp lại bằng chữ in hoa màu trắng, củng cố thêm nhận diện thương hiệu. Cuối cùng, ở phần dưới cùng của màn hình, khẩu hiệu "YOUR SOUNDTRACK, YOUR STORY" được trình bày trang trọng trong dấu ngoặc kép, theo sau bởi - SPIKETUNE -, nhằm truyền tải thông điệp về khả năng cá nhân hóa và kể chuyện thông qua âm nhạc mà ứng dụng mang lại.

Giao diện Đăng nhập (Login Activity Layout): Giao diện này, được xây dựng trong môi trường phát triển Android Studio và thể hiện qua tệp tin activity_login.xml, cho phép người dùng đã có tài khoản truy cập vào ứng dụng. Cấu trúc giao diện bao gồm một ImageView ở vị trí trung tâm phía trên, dự kiến sẽ hiển thị logo của ứng dụng. Bên dưới là một TextView hiển thị tiêu đề "Đăng nhập" (Đăng nhập). Tiếp theo là hai trường nhập liệu EditText, được thiết kế để người dùng nhập thông tin đăng nhập của họ, có thể là tên người dùng, địa chỉ email và mật khẩu. Cuối cùng, một nút Button với nhãn "Đăng nhập" (Đăng nhập) được đặt ở vị trí dễ thấy để người dùng thực hiện hành động đăng nhập. Bản xem trước trực quan (Design View) và khung phác thảo (Blueprint) trong Android Studio cho thấy cách các thành phần này được sắp xếp trên màn hình, hướng đến sự rõ ràng và dễ sử dụng. Mã XML đi kèm định nghĩa các thuộc tính như android:id, android:layout_width, android:layout_height, android:text, và các ràng buộc bố cục để đảm bảo giao diện hiển thị đúng trên các kích thước màn hình khác nhau.

Giao diện Đăng ký (Register Activity Layout hoặc một giao diện nhập liệu tương tự): Tương tự như giao diện đăng nhập, giao diện này (có thể là của tệp tin activity_register.xml hoặc một tệp tin layout khác) đang trong quá trình phát triển trong Android Studio. Nó cũng bao gồm một ImageView ở phía trên, có khả năng hiển thị logo ứng dụng. Tiếp theo là nhiều trường nhập liệu EditText hơn so với giao diện đăng nhập, gợi ý rằng đây là nơi người dùng mới sẽ nhập các thông tin cần thiết để tạo tài khoản, chẳng hạn như tên đầy đủ, tên người dùng, địa chỉ email, mật khẩu và xác nhận mật khẩu. Một nút Button được đặt ở cuối giao diện, có thể có nhãn "Đăng ký" hoặc một nhãn tương tự, để người dùng hoàn tất quá trình đăng ký. Bản xem trước trực quan và khung phác thảo cung cấp cái nhìn về cách các thành phần này được bố trí. Tương tự như giao diện đăng nhập, mã XML định nghĩa cấu trúc và thuộc tính của các thành phần giao diện.
![image](https://github.com/user-attachments/assets/6ac2e046-9c94-41ae-83b7-afd23186c5b1)
### Mục tiêu kiểm tra ở giai đoạn thực thi này:

Tính nhất quán ban đầu của giao diện: Đánh giá sự đồng bộ về mặt thiết kế cơ bản (ví dụ: việc sử dụng logo, màu sắc chủ đạo) giữa màn hình khởi động, đăng nhập và đăng ký (hoặc các giao diện nhập liệu khác).
Tính trực quan và bố cục rõ ràng: Xem xét liệu các thành phần giao diện cơ bản như trường nhập liệu, nút bấm và nhãn có được bố trí một cách logic và dễ hiểu cho người dùng hay không.
Khả năng nhận diện thương hiệu: Đánh giá hiệu quả của việc sử dụng logo và khẩu hiệu trong việc xây dựng và củng cố nhận diện thương hiệu "SPIKETUNE" ngay từ những tương tác đầu tiên của người dùng.
Sự hiện diện và chức năng cơ bản của các thành phần: Xác minh rằng tất cả các thành phần giao diện cần thiết cho các chức năng cơ bản như chào đón người dùng, đăng nhập và đăng ký (hoặc thu thập thông tin) đều đã được triển khai ở mức độ ban đầu.
Tuân thủ các nguyên tắc thiết kế UI/UX cơ bản: Đánh giá xem các thiết kế ban đầu có tuân theo các nguyên tắc cơ bản về trải nghiệm người dùng, chẳng hạn như kích thước các phần tử tương tác đủ lớn, độ tương phản màu sắc phù hợp và luồng tương tác logic hay không.
### Tiếp tục thực thi dự án:
#### Giai đoạn build app, application development and improvement, complete complement, anticipated expansion.
![image](https://github.com/user-attachments/assets/e0a93897-2c1f-42d3-9f49-75f9f8ba14c6)
![image](https://github.com/user-attachments/assets/5ab85975-7aef-4f67-91e3-872292db7555)
![image](https://github.com/user-attachments/assets/e7eb91f6-0c27-4928-a73b-505ee26a8939)
![image](https://github.com/user-attachments/assets/69395b9c-baea-417f-ae9e-9fbab5b822e6)
![image](https://github.com/user-attachments/assets/9d49bece-8d55-4e08-b8be-be54ec930a08)
![image](https://github.com/user-attachments/assets/a1b9645f-363d-4291-903d-851e7d51d0e7)
![image](https://github.com/user-attachments/assets/53107660-969c-4660-9f61-515a16b42fca)
![image](https://github.com/user-attachments/assets/550a9adf-a840-4042-9d26-90668f330845)
![image](https://github.com/user-attachments/assets/d7ca1167-14a5-400f-bd96-034286a8fbd9)
![image](https://github.com/user-attachments/assets/faabcfcd-a694-4728-b641-dcde218d1c4c)
![image](https://github.com/user-attachments/assets/ca6a4e83-9b61-457d-9fa9-9c6b2aff928d)
![image](https://github.com/user-attachments/assets/83a5cc0a-6fe4-429a-aa2f-bf27bef34a2a)
![image](https://github.com/user-attachments/assets/979fb9b3-f033-4473-ae97-e9e9c2adba31)
![image](https://github.com/user-attachments/assets/326ade39-efc3-4288-b90e-5c4597eee270)
![image](https://github.com/user-attachments/assets/2efc197a-43a5-427a-8fed-701235378f17)

----------

![image](https://github.com/user-attachments/assets/9e8b4624-c7fb-4bc2-923e-9171f65485e2)
![image](https://github.com/user-attachments/assets/9bd1cc48-1a75-4432-83ad-f00872a8c35d)
![image](https://github.com/user-attachments/assets/5e4692a4-3d09-4452-a7cf-1fed1cf2988d)
![image](https://github.com/user-attachments/assets/33db4ebb-347f-43db-82c3-91b9e913872d)
![image](https://github.com/user-attachments/assets/1c588a04-d650-4803-973b-d9ac79085ea0)
![image](https://github.com/user-attachments/assets/70e94950-b432-4132-9774-f2264d9052c2)
![image](https://github.com/user-attachments/assets/914e4404-673f-4d5c-9a5e-50938180ab03)
![image](https://github.com/user-attachments/assets/06bfd353-40e4-469f-9ddc-0711d6a45732)
![image](https://github.com/user-attachments/assets/00e59480-c33a-4d9b-8020-1ca3fca391cf)
![image](https://github.com/user-attachments/assets/4b540223-055a-4f44-b7d8-ac24b7203037)
![image](https://github.com/user-attachments/assets/a279e9f2-f83a-4dbe-9ee8-fdbf225a0ff3)

---

## THỜI ĐIỂM HOÀN THIỆN THỰC THI DỰ ÁN
Rest-express (Tên dự án: SpikeTuneTech )
Đây là một dự án ứng dụng web được xây dựng với Express.js ở backend, tích hợp với cơ sở dữ liệu PostgreSQL (qua Drizzle ORM và Neon Serverless), và sử dụng các công nghệ frontend hiện đại như React và Tailwind CSS. Dự án này cũng tích hợp xác thực OpenID Connect sử dụng openid-client và passport.
## Mục lục
•	Giới thiệu
•	Tính năng
•	Cài đặt 
o	Yêu cầu
o	Cài đặt phụ thuộc
o	Biến môi trường
•	Cách chạy dự án 
o	Chế độ phát triển
o	Chế độ sản xuất
•	Cơ sở dữ liệu
•	Cấu trúc dự án
•	Các công nghệ chính
•	Giấy phép
## Giới thiệu
(Viết một đoạn ngắn giới thiệu về dự án của bạn. Ví dụ:) Dự án này là một nền tảng quản lý nhạc trực tuyến (hoặc một mô tả khác phù hợp với ứng dụng của bạn) cho phép người dùng đăng nhập, quản lý profile, và tương tác với nội dung. Nó được thiết kế để dễ dàng bảo trì, mở rộng và tái sử dụng nhờ việc tuân thủ các nguyên tắc thiết kế phần mềm hiện đại và OOP.
## Tính năng
(Liệt kê các tính năng chính của ứng dụng bạn. Ví dụ:)
•	Xác thực người dùng qua OpenID Connect.
•	Quản lý phiên (session) người dùng.
•	Tương tác với cơ sở dữ liệu PostgreSQL.
•	Giao diện người dùng được xây dựng với React và các thư viện Radix UI, Tailwind CSS.
•	(Thêm các tính năng cụ thể khác của ứng dụng của bạn)
## Cài đặt
### Yêu cầu
•	Node.js (phiên bản 20 trở lên được khuyến nghị)
•	npm (thường đi kèm với Node.js)
•	Một instance cơ sở dữ liệu PostgreSQL (ví dụ: từ Neon.tech)
### Cài đặt phụ thuộc
Đầu tiên, điều hướng đến thư mục gốc của dự án và cài đặt tất cả các phụ thuộc:
Bash
npm install
### Biến môi trường
Dự án này sử dụng các biến môi trường để cấu hình. Bạn cần tạo một file .env ở thư mục gốc của dự án với các biến sau:
Code snippet
# Khóa bí mật cho session của Express
SESSION_SECRET="bpbSgh5wjWSWFbqX2j1Y59LoAHis5Ifka8tMUuVeovXICx0nVwPOt9Zg67CCGOA9Kl/b6bY+884+V1Hb/24wvw=="

# Chuỗi kết nối đến cơ sở dữ liệu PostgreSQL (ví dụ: Neon.tech)
DATABASE_URL="postgresql://neondb_owner:npg_08hxrYvCEHGl@ep-soft-heart-a5c09ye3.us-east-2.aws.neon.tech/neondb?sslmode=require"

# Các biến riêng lẻ cho kết nối PostgreSQL (có thể được sử dụng bởi một số thư viện)
PGDATABASE="neondb"
PGHOST="ep-soft-heart-a5c09ye3.us-east-2.aws.neon.tech"
PGPORT="5432"
PGUSER="neondb_owner"
PGPASSWORD="npg_08hxrYvCEHGl"

# Các biến môi trường cho OpenID Connect (được sử dụng trong server/replitAuth.ts)
# REPLIT_DOMAINS="your-domain.com,another-domain.com" # Chỉ định các domain được phép
# REPL_ID="your_client_id"
# REPL_SECRET="your_client_secret"
# ISSUER_URL="https://accounts.replit.com" # Hoặc URL issuer OIDC của bạn
### Lưu ý quan trọng:
•	Không bao giờ đẩy file .env lên GitHub hoặc các kho lưu trữ công khai! Thêm .env vào file .gitignore của bạn.
•	Bạn cần thay thế các giá trị placeholder như your_client_id, your_client_secret, và your-domain.com bằng thông tin thực tế của bạn. SESSION_SECRET nên là một chuỗi ngẫu nhiên, mạnh mẽ.
#Cách chạy dự án
## Chế độ phát triển
Để chạy ứng dụng ở chế độ phát triển với tính năng hot-reloading (nếu được cấu hình bởi Vite cho frontend) và TypeScript transpilation on-the-fly cho backend:
Bash
npm run dev
Ứng dụng sẽ khởi động và thường có thể truy cập tại http://localhost:3000 (hoặc cổng mà bạn đã cấu hình).
## Chế độ sản xuất
Để tạo bản build cuối cùng và chạy ứng dụng ở chế độ sản xuất:
### 1. Build ứng dụng:
Bash
npm run build
Lệnh này sẽ biên dịch cả phần frontend (Vite) và backend (esbuild) vào thư mục dist.
    ### 2. Chạy bản đã build:
Bash
npm run start
Ứng dụng sẽ khởi động ở chế độ production, thường nhanh hơn và tối ưu hơn.
## Cơ sở dữ liệu
Dự án này sử dụng Drizzle ORM để tương tác với PostgreSQL.
•	Đẩy lược đồ cơ sở dữ liệu: Để đồng bộ lược đồ Drizzle của bạn với cơ sở dữ liệu hiện tại (tạo hoặc cập nhật bảng): 
Bash
npm run db:push
(Đảm bảo DATABASE_URL trong .env đã được cấu hình chính xác trước khi chạy lệnh này.)
## Cấu trúc dự án
Dự án này tuân theo một cấu trúc thư mục phân tách giữa mã server và client:

 
.
 ## Các công nghệ chính
### Backend: 
o	Node.js
o	Express.js: Framework web nhanh, không ý kiến.
o	TypeScript: Ngôn ngữ lập trình với kiểu tĩnh.
o	Drizzle ORM: ORM cho cơ sở dữ liệu.
o	@neondatabase/serverless: Kết nối với cơ sở dữ liệu Neon.
o	openid-client: Thư viện OpenID Connect.
o	passport & express-session: Quản lý xác thực và phiên.
### Frontend: 
o	React: Thư viện JavaScript cho xây dựng giao diện người dùng.
o	Vite: Công cụ build frontend nhanh.
o	Tailwind CSS: Framework CSS utility-first.
o	Radix UI: Thư viện thành phần UI không kiểu dáng.
o	@tanstack/react-query: Quản lý trạng thái server.
### Công cụ: 
o	tsx: Trình chạy TypeScript nhanh.
o	esbuild: Trình đóng gói JavaScript nhanh.
o	cross-env: Cấu hình biến môi trường đa nền tảng.

---

## KHẢ NĂNG BẢO TRÌ, SỬ DỤNG LẠI VÀ MỞ RỘNG DỰA THEO 4 TIÊU CHÍ OOP
# Tuân thủ chặt chẽ các nguyên tắc OOP và các nguyên tắc thiết kế phần mềm hiện đại khác

Dưới đây là phân tích dựa trên các giả định hợp lý về một hệ thống lớn như Spotify:

## 1. Tính đóng gói (Encapsulation)

**Mô tả nguyên tắc:**  
Tính đóng gói là việc nhóm dữ liệu (thuộc tính) và các phương thức (hành vi) thao tác trên dữ liệu đó vào một đơn vị duy nhất (đối tượng/lớp), đồng thời ẩn đi các chi tiết triển khai nội bộ và chỉ phơi bày ra giao diện công khai (public interface) cho phép tương tác. Điều này giới hạn truy cập trực tiếp vào các thành phần bên trong.

**Khả năng áp dụng trong Spotify:**  
- **Bảo trì:**  
  - Dễ dàng sửa đổi nội bộ: Các thành phần bên trong của một module (ví dụ: module quản lý playlist, module stream nhạc, module thanh toán) có thể được thay đổi, tối ưu hóa hoặc sửa lỗi mà không ảnh hưởng đến các module khác, miễn là giao diện công khai của chúng không thay đổi.  
  - Giảm sự phụ thuộc: Các module không cần biết chi tiết triển khai của nhau, chỉ cần biết cách giao tiếp thông qua giao diện đã định nghĩa. Điều này làm giảm đáng kể khả năng phát sinh lỗi lan truyền khi có thay đổi.  

- **Sử dụng lại:**  
  - Module độc lập: Các thành phần được đóng gói có thể được tái sử dụng dễ dàng hơn ở các phần khác nhau của hệ thống hoặc trong các dịch vụ vi mô (microservices) khác. Ví dụ, một module quản lý tài khoản người dùng có thể được tái sử dụng cho các dịch vụ khác của Spotify (ví dụ: podcast, audiobook) mà không cần phải viết lại từ đầu.  
  - Tái sử dụng giao diện: Các giao diện được đóng gói giúp các nhà phát triển dễ dàng hiểu cách tương tác với một module mà không cần đi sâu vào chi tiết.  

- **Mở rộng:**  
  - Thêm tính năng mới an toàn: Khi muốn thêm một tính năng mới (ví dụ: một phương thức thanh toán mới, một loại nội dung mới), các nhà phát triển có thể tạo ra các module mới hoặc mở rộng các module hiện có thông qua giao diện công khai, mà không làm hỏng cấu trúc hiện có.  
  - Phát triển song song: Các nhóm khác nhau có thể làm việc trên các module khác nhau đồng thời mà không bị chồng chéo quá nhiều, nhờ vào việc định nghĩa rõ ràng các giao diện.  

## 2. Tính kế thừa (Inheritance)

**Mô tả nguyên tắc:**  
Tính kế thừa cho phép một lớp mới (lớp con) thừa hưởng các thuộc tính và phương thức từ một lớp hiện có (lớp cha). Điều này giúp tái sử dụng mã, thiết lập mối quan hệ "is-a" (là một loại) và xây dựng một hệ thống phân cấp các đối tượng.

**Khả năng áp dụng trong Spotify:**  
- **Bảo trì:**  
  - Giảm trùng lặp mã: Mã chung (như thuộc tính của bài hát, album, nghệ sĩ) được định nghĩa ở lớp cha và được tái sử dụng bởi các lớp con, giúp dễ dàng bảo trì hơn vì bạn chỉ cần sửa đổi ở một nơi.  
  - Dễ dàng theo dõi sự thay đổi: Khi một thay đổi được thực hiện ở lớp cha, nó sẽ tự động áp dụng cho tất cả các lớp con, giảm thiểu công sức cập nhật.  

- **Sử dụng lại:**  
  - Tái sử dụng mã một cách hiệu quả: Các lớp con có thể kế thừa và tái sử dụng hành vi cũng như trạng thái từ lớp cha, thay vì phải viết lại. Ví dụ: AudioContent có thể là lớp cha cho Song, Podcast, Audiobook, mỗi lớp con sẽ thừa hưởng các thuộc tính cơ bản như title, duration, artist.  
  - Xây dựng thư viện và framework: Các thư viện nội bộ của Spotify có thể sử dụng kế thừa để cung cấp các lớp cơ sở cho các loại đối tượng tương tự.  

- **Mở rộng:**  
  - Thêm loại nội dung mới: Khi Spotify muốn thêm một loại nội dung mới (ví dụ: "Video Clip âm nhạc"), họ có thể tạo một lớp mới kế thừa từ lớp MediaContent hoặc AudioContent hiện có, và chỉ cần thêm các thuộc tính và phương thức đặc trưng cho loại nội dung mới đó.  
  - Mở rộng hành vi hiện có: Lớp con có thể ghi đè (override) các phương thức của lớp cha để thay đổi hoặc mở rộng hành vi mà không làm hỏng các phần khác của hệ thống.  

## 3. Tính đa hình (Polymorphism)

**Mô tả nguyên tắc:**  
Tính đa hình cho phép các đối tượng thuộc các lớp khác nhau (nhưng có cùng lớp cha hoặc cùng triển khai một giao diện) được xử lý theo cùng một cách thông qua một giao diện chung. Nó có nghĩa là "nhiều hình thức" – một phương thức có thể có các triển khai khác nhau trong các lớp khác nhau.

**Khả năng áp dụng trong Spotify:**  

### Bảo trì:  
- Đơn giản hóa mã: Mã trở nên đơn giản hơn vì bạn có thể làm việc với các đối tượng ở cấp độ trừu tượng cao hơn, mà không cần biết chính xác loại đối tượng cụ thể là gì. Ví dụ, một hàm phát nội dung chỉ cần biết nó nhận vào một đối tượng MediaContent và gọi phương thức play(), không cần quan tâm đó là Song, Podcast hay Audiobook.  
- Dễ dàng sửa đổi và thêm loại mới: Khi một loại nội dung mới được thêm vào, mã hiện có không cần phải thay đổi, miễn là loại mới đó tuân thủ giao diện chung.  

### Sử dụng lại:  
- Thiết kế linh hoạt: Các thành phần có thể được thiết kế để hoạt động với nhiều loại đối tượng khác nhau, tăng tính linh hoạt và khả năng tái sử dụng của các hàm và module. Ví dụ, một giao diện IPlayable có thể được triển khai bởi Song, Podcast, Audiobook, và bất kỳ hàm nào nhận IPlayable đều có thể phát bất kỳ loại nội dung nào.  
- Tái sử dụng API: Các API chung có thể được sử dụng để tương tác với các đối tượng đa hình, thay vì phải tạo ra các API riêng biệt cho từng loại đối tượng.  

### Mở rộng:  
- Thêm loại nội dung mới mà không ảnh hưởng đến code cũ: Đây là lợi ích lớn nhất. Khi Spotify thêm một loại nội dung mới (ví dụ: Live Concert, Audiobook), họ chỉ cần đảm bảo rằng lớp mới này triển khai cùng một giao diện (ví dụ: IPlayable) mà các lớp nội dung khác đã làm. Các thành phần phát lại hiện có sẽ tự động hoạt động với loại nội dung mới mà không cần sửa đổi.  
- Hệ thống plugin/mở rộng: Spotify có thể sử dụng đa hình để hỗ trợ các plugin hoặc tích hợp bên ngoài, nơi các nhà phát triển bên thứ ba có thể cung cấp các triển khai mới của một giao diện đã định nghĩa.  

## Kết luận

Việc áp dụng chặt chẽ 3 nguyên tắc OOP (đóng gói, kế thừa, đa hình) là nền tảng cho khả năng bảo trì, sử dụng lại và mở rộng của một hệ thống phức tạp như Spotify. Nó cho phép các nhóm phát triển lớn làm việc độc lập trên các phần khác nhau của hệ thống, thêm tính năng mới một cách linh hoạt, sửa lỗi hiệu quả và tái sử dụng mã một cách tối ưu, điều cực kỳ quan trọng đối với một nền tảng dịch vụ liên tục phát triển và có hàng triệu người dùng.



---

## LICENSE
MIT License

Copyright (c) 2025 MobileDeviceProgramming

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


















